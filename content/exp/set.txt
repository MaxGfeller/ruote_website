---
title: set expression
names: ["rset", "set", "unset"]
---

h2. set


Setting a workitem field or a process variable.

<pre class="brush: ruby">
  sequence do
    set :field => 'subject', :value => 'food and beverage'
    set :field => 'date', :val => 'tomorrow'
    participant :ref => 'attendees'
  end
</pre>

:field can be abbreviated to :f or :fld. :variable can be abbreviated to
:v or :var. Likewise, :val and :value are interchangeable.

h3. field_value, variable_value

Usually, grabbing a value from a field or a value will look like

<pre class="brush: ruby">
  set :f => 'my_field', :value => '${v:my_variable}'
</pre>

But doing those ${} substitutions always result in a string result. What
if the variable or the field holds a non-string value ?

<pre class="brush: ruby">
  set :f => 'my_field', :var_value => 'my_variable'
</pre>

Is the way to go then. 'set' understands v_value, var_value, variable_value
and f_value, fld_value and field_value.

h3. :escape

If the value to insert contains ${} stuff but this has to be preserved,
setting the attribute :escape to true will do the trick.

<pre class="brush: ruby">
  set :f => 'my_field', :value => 'oh and ${whatever}', :escape => true
</pre>

h3. ruote 2.0's shorter form

Ruote 2.0 introduces a shorter form for the 'set' expression :

<pre class="brush: ruby">
  sequence do
    set :field => 'f', :value => 'val0'
    set :variable => 'v', :value => 'val1'
    set :field => 'f_${v:v}', :value => 'val2'
  end
</pre>

can be rewritten as

<pre class="brush: ruby">
  sequence do
    set 'f:f' => 'val0'
    set 'v:v' => 'val1'
    set 'f:f_${v:v}' => 'val2'
  end
</pre>

since 'f:' is the default for the 'dollar notation', the shortest form
becomes

<pre class="brush: ruby">
  sequence do
    set 'f' => 'val0'
    set 'v:v' => 'val1'
    set 'f_${v:v}' => 'val2'
  end
</pre>

h3. set and rset

Some gems (Sinatra) for example may provide a set method that hides calls
to set when building process definitions (see http://groups.google.com/group/openwferu-users/browse_thread/thread/9ac606e30ada686e)

A workaround is to write 'rset' instead of 'set'.

<pre class="brush: ruby">
  rset 'customer' => 'Jeff'

</pre>

h3. unset

'unset' is the counterpart to 'set', it removes a field (or a variable)

<pre class="brush: ruby">
  unset :field => 'customer_name'
  unset :f => 'customer_name'
  unset :variable => 'vx'
  unset :var => 'vx'
  unset :v => 'vx'
</pre>

or simply

<pre class="brush: ruby">
  unset 'f:customer_name'
  unset 'customer_name' # yes, it's field by default
  unset 'v:vx'

</pre>

h3. using set with a block

(not a very common usage, introduced by ruote 2.3.0)

'set' can be used with a block. It then behaves like a 'sequence' and
picks its value in the workitem field named '__result__'.

<pre class="brush: ruby">
  set 'customer_name' do
    participant 'alice'
    participant 'bob'
  end
</pre>

Here, alice or bob may set the field '__result__' to some value,
that will get picked as the value of the field 'customer_name'.

Note that inside the set, a blank variable scope will be used (like in
a 'let).


h3. __result__

'set' and 'unset' place the [un]set value in the field named __result__.

<pre class="brush: ruby">
  sequence do
    set 'f0' => 2
    participant 'x${__result__}''
  end
</pre>

will route a workitem to the participant named 'x2'.

