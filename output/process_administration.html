<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />
    <title>ruote - process administration</title>
    <script src='/js/shCore.js'></script>
    <script src='/js/shBrushRuby.js'></script>
    <script src='/js/shBrushJScript.js'></script>
    <script src='/js/shBrushXml.js'></script>
    <link href='/css/reset.css' rel='stylesheet' type='text/css' />
    <link href='/css/shCore.css' rel='stylesheet' type='text/css' />
    <link href='/css/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <link href='/css/ruote.css' rel='stylesheet' type='text/css' />
  </head><body>
    <div id='container'>
      <div id='header'>
        <div id='header-top'>
          <div id='header-left'>
            <a href='/'>
              <img align='left' src='/images/ruote.png' />
              <span id='ruote' onclick="location.href = '/'; return true;">
                ruote 2.1
              </span>
            </a>
          </div>
          <div id='header-right'>
          </div>
        </div>
        <div id='header-bottom'>
          <div id='header-subtitle'>
            open source ruby workflow engine
          </div>
          <div id='header-menu'>
            <a href='documentation.html' title='documentation'>doc</a>
            <a href='source.html' title='source code'>source</a>
            <a href='download.html' title='download'>download</a>
            <a href='lists.html' title='mailing lists and irc'>lists</a>
            <a href='http://jmettraux.wordpress.com' title='blog'>blog</a>
            <a href='map.html' title='map'>map</a>
            <a class='nihongo' href='ja.html' title='日本語'>日本語</a>
          </div>
        </div>
      </div>
      <div id='content'>
        <h2>[business] process administration</h2>
        <p>The model of a business process usually focuses on a &#8220;happy path&#8221;, everything happening according to the plan.</p>
        <p>A few alternative paths may be added explicitely. Provisions for errors and timeouts may explicitely be added, thanks to <a href="common_attributes.html#on_error">:on_error</a> and <a href="common_attributes.html#on_timeout">:on_timeout</a>.</p>
        <p>Sometimes, this is not enough. Processes may fall into errors, may stall (a participant reply got lost and there is no timeout) or they may simply become obsolete due to changes in their context.</p>
        <p>Deciding whether an exception (error, timeout, &#8230;) is dealt explicitely in the process definition often requires experience.</p>
        <p>This page is about manipulating process instances.</p>
        <p>Here is the span of possible actions :</p>
        <ul>
        	<li><a href="#query">querying</a> the engine about running process instances. Not an action, rather an observation</li>
        </ul>
        <ul>
        	<li><a href="#cancelling">cancelling</a> processes or segments of processes</li>
        	<li><a href="#cancelling_process">cancelling process instances</a></li>
        	<li><a href="#cancelling_expression">cancelling expressions</a></li>
        	<li><a href="#on_cancel">on_cancel</a></li>
        	<li><a href="#killing">killing vs cancelling</a></li>
        </ul>
        <ul>
        	<li><a href="#re_applying">re_applying</a> segments of process instances</li>
        	<li><a href="#re_applying_stalled">re_applying a stalled expression</a></li>
        	<li><a href="#re_applying_tree">re_applying a tree</a></li>
        	<li><a href="#re_applying_fields">re_applying and changing the [workitem] fields</a></li>
        </ul>
        <ul>
        	<li><a href="#errors">errors</a></li>
        	<li><a href="#errors_replay">replaying at errors</a></li>
        	<li><a href="#errors_cancel">cancelling at errors</a></li>
        	<li><a href="#on_error">on_error</a></li>
        </ul>
        <hr />
        <h3 id="query">querying the engine about running process instances</h3>
        <p>To list all the processes currently running in the engine (<a href="http://ruote.rubyforge.org/rdoc/Ruote/Engine.html#processes-instance_method">rdoc</a>) :</p>
        <pre class="brush: ruby">
          statuses = engine.processes
        </pre>
        <p>To query about a process, known by its &#8220;wfid&#8221; (workflow instance id) (<a href="http://ruote.rubyforge.org/rdoc/Ruote/Engine.html#process-instance_method">rdoc</a>) :</p>
        <pre class="brush: ruby">
          status = engine.process(wfid)
        </pre>
        <p>Those two methods return <a href="http://ruote.rubyforge.org/rdoc/Ruote/ProcessStatus.html">ProcessStatus</a> instances.</p>
        <hr />
        <h3 id="cancelling">cancelling</h3>
        <p>Cancelling is about terminating the execution of a process instance or of a branch of it.</p>
        <p>Cancelling cannot occur in one operation. The engine traverses the tree of execution and cancels alive expressions one by one. Active participants receive a cancel message indicating which the id of the workitem to cancel.</p>
        <h4 id="cancelling_process">cancelling : process instances</h4>
        <pre class="brush: ruby">
          engine.cancel_process(wfid)
        </pre>
        <p>Warning : as explained cancelling a process or a branch of a process isn&#8217;t instantaneous.</p>
        <h4 id="cancelling_expression">cancelling : expressions</h4>
        <p>Perhaps, the most common use case for &#8220;cancelling an expression&#8221; is cancelling a participant expression.</p>
        <p>Let&#8217;s say you have this process :</p>
        <div style="width: 100%; position: relative;">
        <pre class="brush: ruby">
          Ruote.process_definition do
            sequence do
              logistics
              delivery
              accounting
            end
          end
        </pre>
        <div style="position: absolute; top: -20px; right: 75px;">
        <img src="/images/cancelling_expression.png" width="100%"/>
        </div>
        </div>
        <p>For some reason, this process was triggered for an online product, which was downloaded successfully. The delivery is not necessary, but the delivery participant has already received the workitem for this process instance.</p>
        <p>Cancelling the delivery participant expression would let the flow continue to &#8220;accounting&#8221;. Programmatically that would look like :</p>
        <pre class="brush: ruby">
          status = engine.process(wfid)
        
          exp = status.expressions.first
        
          engine.cancel_expression(exp.fei)
        </pre>
        <p>Warning : as explained cancelling a process or a branch of a process isn&#8217;t instantaneous.</p>
        <h4 id="on_cancel">on_cancel</h4>
        <p>Most of the time, the process definition attempts to model the &#8220;happy path&#8221;, the process as it occurs 95% of the time. One may want to go a step further and incclude provisions for errors (see <a href="#on_error">on_error</a>) and for cancellations.</p>
        <pre class="brush: ruby">
          Ruote.process_definition do
            sequence :on_cancel =&gt; 'admin' do
              logistics
              delivery
              accounting
            end
          end
        </pre>
        <p>In this process definition, if the process or the sequence gets cancelled, the &#8216;admin&#8217; subprocess (or the participant &#8216;admin&#8217;) will be applied (or simply receive a workitem).</p>
        <p>More info about <a href="common_attributes.html#on_cancel">on_cancel</a>.</p>
        <h4 id="killing">killing vs cancelling</h4>
        <p>Processes (and expressions) can be cancelled or they can be killed. Killing looks much like cancelling, except that any <a href="common_attributes.html#on_cancel">on_cancel</a> will be ignored.</p>
        <hr />
        <h3 id="re_applying">re_applying</h3>
        <p>The <a href="http://ruote.rubyforge.org/rdoc/Ruote/Engine.html#method-i-re_apply" title="fei, options">Engine#re_apply</a> method cancels and expression and re_applies. It has a few options for dealing with some process repair tasks.</p>
        <p>Most of the technique described here are tested in ruote&#8217;s <a href="http://github.com/jmettraux/ruote/blob/ruote2.1/test/functional/ft_14_re_apply.rb">ft_14_re_apply.rb</a></p>
        <h4 id="re_applying_stalled">re_applying a stalled [participant] expression</h4>
        <p>Sometimes participants don&#8217;t reply and the participant expression that emitted the workitem to them is stuck waiting. Or simply the engine could have been down when the participant answer came and the answer got lost.</p>
        <p>With a &#8216;re_apply&#8217;, it&#8217;s possible to re-apply the delivery and hopefully restart the interaction (though that could ultimately depend on the participant implementation).</p>
        <pre class="brush: ruby">
          pdef = Ruote.process_definition do
            sequence do
              alpha
              bravo
            end
          end
        
          wfid = engine.launch(pdef)
        
          # ... process stalls at participant alpha ...
        
          stalled_fexp = engine.process(wfid).expressions.last
            #
            # expressions in process status (as returned by Engine#process) are
            # ordered with the root as the first and the leaves in the last positions
        
          engine.re_apply(stalled_fexp.fei)
            #
            # will cancel the expression at 'alpha' and re_apply it, triggering
            # a new dispatch to the participant alpha points to.
        </pre>
        <h4 id="re_applying_tree">re_applying a process branch that went wrong</h4>
        <p>If a process branch went wrong, it&#8217;s sometimes necessary to redo it.</p>
        <p>Some process developers like to include those &#8220;something went wrong&#8221; paths as extension to the happy path and they use the <a href="exp/cursor.html">cursor</a> expression with some &#8216;rewind&#8217; magic. But sometimes it&#8217;s really necessary to rewind/redo manually.</p>
        <pre class="brush: ruby">
        require 'rubygems'
        require 'yajl'
        require 'ruote'
        
        engine = Ruote::Engine.new(Ruote::Worker.new(Ruote::HashStorage.new))
        
        pdef = Ruote.define do
          sequence do
            alpha
            bravo
            zebulon
          end
        end
        
        class ThisParticipant
          include Ruote::LocalParticipant
          def consume (workitem)
            puts "* #{workitem.participant_name}"
            reply_to_engine(workitem)
          end
        end
        class ThatParticipant
          include Ruote::LocalParticipant
          def consume (workitem)
            puts ". #{workitem.participant_name}"
            # no reply to engine
          end
          def cancel (fei, flavour)
            # ok, let pass
          end
          def do_not_thread; true; end
        end
        
        engine.register_participant 'alpha', ThisParticipant
        engine.register_participant 'bravo', ThisParticipant
        engine.register_participant 'charlie', ThisParticipant
        engine.register_participant 'zebulon', ThatParticipant
        
        #engine.context.logger.noisy = true
        
        wfid = engine.launch(pdef)
        
        engine.wait_for(:zebulon)
        
        # ... process reached 'zebulon', but there something wrong
        #     we need to redo that sequence differently ...
        
        ps = engine.process(wfid)
        
        sequence = ps.expressions.find { |fexp| fexp.fei.expid == '0_0' }
          # first child '0' after the root '0' =&gt; '0_0'
        
        puts "re_applying..."
        
        engine.re_apply(sequence.fei, :tree =&gt; Ruote.to_tree do
          sequence do
            charlie
            bravo
            alpha
          end
        end)
        
        engine.wait_for(wfid)
        </pre>
        <p>(gist at <a href="http://gist.github.com/485559">http://gist.github.com/485559</a>)</p>
        <p>This self-containing example will output :</p>
        <pre>
        * alpha
        * bravo
        . zebulon
        re_applying...
        * charlie
        * bravo
        * alpha
        </pre>
        <p>The key here is the :tree option passed to re_apply, it gives that has to be applied instead of the target expression.</p>
        <h4 id="re_applying_fields">re_applying and changing the [workitem] fields</h4>
        <p>When re_applying, the workitem used for the re_apply is the one used to originally apply.</p>
        <p>The re_apply method accepts the :fields and :merge_in_fields options. :fields completely changes the workitem payload used for the re_apply, while the :merge_in_fields, allows to add new fields to the workitem payload.</p>
        <p>A few examples :</p>
        <pre class="brush: ruby">
        engine.re_apply(fei, :fields =&gt; { 'customer' =&gt; 'Alfred' })
        
        engine.re_apply(fei, :merge_in_fields =&gt; { 'customer' =&gt; 'Alfred' })
        
        engine.re_apply(
          fei,
          :fields =&gt; { 'customer' =&gt; 'Alfred', 'items' =&gt; [ 124, 356, 798 ] },
          :tree =&gt; Ruote.to_tree { sequence { print_invoice; package; ship } })
        </pre>
        <p>&nbsp;</p>
        <hr />
        <h3 id="errors">process errors</h3>
        <p>Each time a process encounters an error (most likely in a participant implementation), the process stops and &#8216;documents&#8217; the error.</p>
        <p>If a process is in two concurrent branches, only the execution of the branch with the error will stop. A process instance can have as many errors has it has concurrent branches.</p>
        <p>Here is a program that runs a process with a unreliable participant :</p>
        <pre class="brush: ruby">
        require 'rubygems'
        require 'ruote'
        
        class TestParticipant
          include Ruote::LocalParticipant
        
          def consume(workitem)
            raise "Houston, something is wrong"
          end
        end
        
        engine = Ruote::Engine.new(Ruote::Worker.new(Ruote::HashStorage.new))
        
        engine.register do
          catchall TestParticipant
        end
        
        pdef = Ruote.process_definition do
          bad
        end
        
        wfid = engine.launch(pdef)
        
        engine.wait_for(wfid)
          # blocks until the process terminates or gets into an error
        
        err = engine.process(wfid).errors.first
        puts "intercepted an error : #{err.message}..."
        </pre>
        <p>It&#8217;s possible to query the engine about the status of a process instance and its errors.</p>
        <p>Once a process got into an error, there are 3 possibilities :</p>
        <ul>
        	<li><a href="#errors_cancel_whole_process">cancel</a> the whole process</li>
        	<li><a href="#errors_cancel">cancel the branch</a> of the process that is in error</li>
        	<li>fix the cause and <a href="#errors_replay">replay</a> at the error</li>
        </ul>
        <p>plus one that has to be prepared in advance :</p>
        <ul>
        	<li>having acknowledged that such an error might occur, set an <a href="#errors_on_error">:on_error</a> attribute on the branch where the error might occur</li>
        </ul>
        <p>Which possibility to use depends on your process and context.</p>
        <h4 id="errors_cancel_whole_process">errors : cancelling the whole process</h4>
        <p>The car won&#8217;t start ? Let&#8217;s dump it.</p>
        <pre class="brush: ruby">
          engine.cancel_process(wfid)
        </pre>
        <h4 id="errors_cancel">errors : cancelling</h4>
        <p>First variant, cancelling at the error point :</p>
        <pre class="brush: ruby">
          ps = engine.process(wfid)
          engine.cancel_expression(ps.errors.first.fei)
        </pre>
        <p>This will make the flow resume right after the expression in error.</p>
        <p>Second variant, cancelling upstream. It sounds nice but it actually requires knowledge of the process definition.</p>
        <p>Consider this process definition :</p>
        <pre class="brush: ruby">
          Ruote.process_definition do
            concurrence do
              alpha
              bravo
              sequence do
                charly
                delta
              end
            end
          end
        </pre>
        <p>If an error occurred at &#8216;charly&#8217;, you could cancel at charly directly, or the sequence, or the concurrence.</p>
        <p>Without looking at the process definition and knowing the participants involved, it&#8217;s hard to cancel &#8220;upstreams&#8221;.</p>
        <p>This alpha-bravo-charly example is expanded at <a href="https://github.com/jmettraux/ruote/blob/ruote2.1/snips/where_to_cancel.rb">https://github.com/jmettraux/ruote/blob/ruote2.1/snips/where_to_cancel.rb</a></p>
        <h4 id="errors_replay">errors : replaying</h4>
        <p>Launching a process, intercepting the error, fixing its cause and replaying :</p>
        <pre class="brush: ruby">
        require 'rubygems'
        require 'ruote'
        
        $mode = :fail
        
        class TestParticipant
          include Ruote::LocalParticipant
        
          def consume(workitem)
            raise "Houston, something is wrong" if $mode == :fail
            reply_to_engine(workitem)
          end
        end
        
        engine = Ruote::Engine.new(Ruote::Worker.new(Ruote::HashStorage.new))
        
        engine.register do
          catchall TestParticipant
        end
        
        pdef = Ruote.process_definition do
          bad
        end
        
        wfid = engine.launch(pdef)
        
        engine.wait_for(wfid)
        
        err = engine.process(wfid).errors.first
        puts "intercepted an error : #{err.message}... fixing..."
        
        $mode = :success
          # fixing the cause of the error
        
        engine.replay_at_error(err)
        
        engine.wait_for(wfid)
        
        p engine.process(wfid)
          # =&gt; nil (the process is over)
        </pre>
        <h4 id="errors_on_error">on_error</h4>
        <p>The <a href="http://localhost:4331/common_attributes.html#on_error">:on_error attribute</a> is explained in the &#8220;common attributes&#8221; page.</p>
        <p>(isn&#8217;t prevention of errors better than dealing with them automatically ?)</p>
      </div>
      <div id='footer'>
        <div id='footer-left'>
          this website was created with
          <a href='http://nanoc.stoneship.org'>nanoc</a>
          and
          <a href='http://alexgorbatchev.com/SyntaxHighlighter/'>syntax highlighter</a>
        </div>
        <div id='footer-right'>
          &copy; 2005-2010 the ruote team
        </div>
      </div>
    </div>
    <script type='text/javascript'>
      //<![CDATA[
        SyntaxHighlighter.all();
      //]]>
    </script>
    <script src='http://www.google-analytics.com/ga.js' type='text/javascript'></script>
    <script type='text/javascript'>
      //<![CDATA[
        if (location.hostname != 'localhost' && location.hostname != '127.0.0.1') {
          var pageTracker=_gat._getTracker('UA-138748-2');
          pageTracker._initData();
          pageTracker._trackPageview();
        }
      //]]>
    </script>
  </body>
</html>
