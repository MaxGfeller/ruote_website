<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />
    <title>ruote - common attributes</title>
    <script src='/js/shCore.js'></script>
    <script src='/js/shBrushRuby.js'></script>
    <script src='/js/shBrushJScript.js'></script>
    <script src='/js/shBrushXml.js'></script>
    <link href='/css/reset.css' rel='stylesheet' type='text/css' />
    <link href='/css/shCore.css' rel='stylesheet' type='text/css' />
    <link href='/css/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <link href='/css/ruote.css' rel='stylesheet' type='text/css' />
  </head><body>
    <div id='container'>
      <div id='header'>
        <div id='header-top'>
          <div id='header-left'>
            <a href='/'>
              <img src='/images/ruote.png' />
            </a>
            <div id='header-subtitle'>
              open source ruby workflow engine
            </div>
          </div>
          <div id='header-right'>
          </div>
        </div>
        <div id='nav'>
          <span>
            <a href='documentation.html' title='documentation'>doc</a>
            <a href='source.html' title='source code'>source</a>
            <a href='download.html' title='download'>download</a>
            <a href='lists.html' title='mailing lists and irc'>lists</a>
            <a href='http://jmettraux.wordpress.com' title='blog'>blog</a>
            <a href='map.html' title='map'>map</a>
            <a class='nihongo' href='ja.html' title='日本語'>日本語</a>
          </span>
        </div>
      </div>
      <div id='content'>
        <h2>attributes common to all expressions</h2>
        <p>The attributes listed on this page may be used with any expression.</p>
        <ul>
        	<li><a href="#timeout">:timeout</a></li>
        	<li><a href="#if_unless">:if or :unless</a></li>
        	<li><a href="#forget">:forget</a></li>
        	<li><a href="#on_error">:on_error</a></li>
        	<li><a href="#on_cancel">:on_cancel</a></li>
        	<li><a href="#on_timeout">:on_timeout</a></li>
        	<li><a href="#tag">:tag</a></li>
        </ul>
        <hr/>
        <h3 id="timeout">:timeout</h3>
        <p>If after two days, the two reviewers couldn&#8217;t do their work, the process instance will resume to the editor :</p>
        <pre class="brush: ruby">
          sequence do
            participant :ref =&gt; 'author'
            sequence :timeout =&gt; '2d' do
              participant :ref =&gt; 'reviewer1'
              participant :ref =&gt; 'reviewer2'
            end
            participant :ref =&gt; 'editor'
          end
        </pre>
        <p>:timeout understands h, m, d, s (respectively hour, minute, day, second). It also understands y, M, w (for year, Month and week), but they are rarely used.</p>
        <p>It&#8217;s OK to give an absolute date to the :timeout attribute :</p>
        <pre class="brush: ruby">
          participant :ref =&gt; 'author', :timeout =&gt; 'Sun Jan 24 17:28:28 +0900 2010'
        </pre>
        <p>But most of the time absolute dates are fetched from process variables or workitem fields :</p>
        <pre class="brush: ruby">
          participant :ref =&gt; 'author', :timeout =&gt; '${f:time_limit}'
        </pre>
        <p>Please note that <a href="exp/participant.html">participants</a> may have their say in their timeout.</p>
        <p>You might also have a look at the <a href="#on_timeout">:on_timeout</a> attribute.</p>
        <h3 id="if_unless">:if / :unless</h3>
        <p>These two attributes accept a condition string. If the condition evaluates to true (or false for :unless), the expression will get executed, else not.</p>
        <p>The <span class="caps">CEO</span> will receive a workitem / task only if the budget (stored in a workitem field) exceeds 23000 :</p>
        <pre class="brush: ruby">
          concurrence do
            participant 'ceo', :if =&gt; '${f:budget} &gt; 23000'
            participant 'cfo'
            participant '${f:bu_head}'
          end
        </pre>
        <p>Any expression may use :if / :unless :</p>
        <pre class="brush: ruby">
          cursor do
            subprocess 'gather_data'
            subprocess 'generate_graphs'
            participant 'quality_control'
            rewind :unless =&gt; '${f:sufficient_data}'
            subprocess 'generate_pdfs'
            # over
          end
        </pre>
        <p>Really any :</p>
        <pre class="brush: ruby">
          sequence do
            sequence :if =&gt; '${f:weather} == rainy' do
              rent_tent
              rent_heating_system
            end
            concurrence do
              sequence do
                emit_invitations
                gather_responses :timeout =&gt; '3w'
              end
              cursor :if =&gt; '${f:orchestra}' do
                gather_orchestra
                decide_about_orchestra
                reserve_orchestra
                rewind :if =&gt; '${f:orchestra_already_taken}'
              end
              participant 'mayor', :task =&gt; 'notification'
            end
          end
        </pre>
        <h3 id="forget">:forget</h3>
        <p>An expression flagged with :forget =&gt; true or :forget =&gt; &#8216;true&#8217; gets forgotten, it is considered has having replied immediately to its parent expression, though its &#8216;execution&#8217; is resuming independently.</p>
        <pre class="brush: ruby">
          concurrence do
            participant 'alfred'
            participant 'bob'
            participant 'charly', :forget =&gt; true
          end
        </pre>
        <p>Charly will receive a workitem, but the concurrence will receive a reply immediately, thus, the concurrence (and the rest of the process) will resume as soon as both Alfred and Bob have replied.</p>
        <p>It can be used for some kind of rough fire and forget concurrency :</p>
        <pre class="brush: ruby">
          sequence do
            participant 'alfred', :forget =&gt; true
            participant 'bob', :forget =&gt; true
            participant 'charly', :forget =&gt; true
          end
        </pre>
        <h3 id="on_error">:on_error</h3>
        <p>By default, any error in a process instance gets logged and the segment of process where it occurred is stalled. It&#8217;s then possible to replay_at_error() the issue.</p>
        <p>What if you want to specify the &#8220;on error&#8221; behaviour directly in the process definition ?</p>
        <p>:on_error is the closest thing to the begin/rescue, try/catch found in regular programming languages.</p>
        <pre class="brush: ruby">
        Ruote.process_definition :name =&gt; 'x' do
        
          sequence :on_error =&gt; 'handle_issue' do
            participant 'alpha'
            cursor do
              # ...
            end
          end
        
          define 'handle_issue' do
            participant 'supervisor', :msg =&gt; 'process ${wfid} has gone ballistic'
          end
        end
        </pre>
        <p>If there is an error (at any level/depth) inside of our sequence, the whole branch of the &#8220;sequence&#8221; will get cancelled and then replaced by the element indicated in :on_error.</p>
        <p>There will be no error registered in the error journal (unless there is an error in the handling participant/subprocess itself).</p>
        <p>:on_error must point to a subprocess or a participant, or a command like &#8220;redo&#8221; or &#8220;undo&#8221;.</p>
        <p>When it points to a subprocess, the branch in error gets replaced by an instance that subprocess. When it points to a participant branch gets replaced by a single workitem despatchement to the participant.</p>
        <p>If :redo or &#8216;redo&#8217; is given, the process branch will get cancelled and retried :</p>
        <pre class="brush: ruby">
          sequence :on_error =&gt; :redo do
            # ...
          end
        </pre>
        <p>If :undo or &#8216;undo&#8217; is passed, the branch will get cancelled and the flow will resume :</p>
        <pre class="brush: ruby">
          sequence do
            participant 'notify_bu', :on_error =&gt; :undo
              # we don't care if the notification fails
            participant 'bu_head'
              # business as usual
          end
        </pre>
        <p><span class="caps">NOTE</span> : there are plans for making the <a href="exp/listen.html">listen</a> expression listen to errors, stay tuned.</p>
        <h3 id="on_cancel">:on_cancel</h3>
        <p>on_cancel is used to point at a subprocess or a participant that should be invoked / receive a workitem in case a [segment of a] process gets cancelled.</p>
        <pre class="brush: ruby">
        pdef = Ruote.process_definition :name =&gt; 'aircraft carrier' do
          cursor :on_cancel =&gt; 'decommission' do
            concurrence do
              participant 'naval team', :task =&gt; 'operate ship'
              participant 'air team', :task =&gt; 'operate planes'
            end
          end
          define 'decommission' do
            concurrence do
              participant 'naval team', :task =&gt; 'decom weapons'
              participant 'air team', :task =&gt; 'decom aircrafts'
            end
          end
        end
        </pre>
        <p>In this process, the aircraft is operated. Upon cancelling, the subprocess &#8216;decommission&#8217; is triggered, where the teams get different missions.</p>
        <p>Note that, unlike :on_error, when an expression inside an :on_cancel enabled expression is cancelled, that will not trigger the :on_cancel. For example, if the &#8216;operate planes&#8217; activity is cancelled, that will not trigger &#8216;decommission&#8217;. The trigger will occur if the cursor or the whole process instance is cancelled.</p>
        <p>(note as well that when a process get killed, its on_cancel attributes will not trigger)</p>
        <h3 id="on_timeout">:on_timeout</h3>
        <p>On top of this page figures the description of the <a href="#timeout">:timeout</a> attribute. The :on_timeout attribute is a complement. It indicates what to do (participant or subprocess) when the timeout does trigger.</p>
        <p>Apart from the name of a subprocess or a participant, :on_timeout can also take the &#8216;redo&#8217; or the &#8216;error&#8217; value.</p>
        <p>The &#8216;redo&#8217; value indicates that on timeout, the flagged expression should get cancelled (along with any children it may have) and be re-applied.</p>
        <p>The &#8216;error&#8217; value forces the process into error upon timeout (whereas the default timeout behaviour is to resume the flow). A process segment in error is blocked and requires an admin interventation (see <a href="process_administration.html">process administration</a>).</p>
        <pre class="brush: ruby">
          sequence do
            participant 'author'
            participant 'reviewer', :timeout =&gt; '3d', :on_timeout =&gt; 'redo'
            participant 'editor'
          end
        </pre>
        <p>In this example, the reviewer will receive a fresh workitem every 3 days, until he replies by himself to the flow (which will resume to the editor participant).</p>
        <h3 id="tag">:tag</h3>
        <p>The tag attribute is used to tag a segment of a process.</p>
        <pre class="brush: ruby">
        Ruote.process_definition do
          sequence do
            sequence :tag =&gt; 'phase 1' do
              alice
              bob
            end
            sequence :tag =&gt; 'phase 2' do
              charly
              david
            end
          end
        end
        </pre>
        <p>These tags then appear in the process variables :</p>
        <pre class="brush: ruby">
        p engine.process(wfid).tags.keys
          # =&gt; [ "phase 1" ]
        </pre>
        <p>In this way, :tag can be used to flag large segments of process instances. Eras, phases, chapter, &#8230; Name it how you want.</p>
        <p>(ruote 2.1.12 will probably add a tags field to its workitems, that keeps track of the currently seen tags)</p>
        <p>The :tag is used as well by the <a href="exp/redo.html">_redo</a> and the <a href="exp/undo.html">undo</a> (cancel) expression.</p>
        <p>The <a href="exp/cursor.html">cursor / repeat</a> expressions can be tagged too, when the cursor/loop has to be manipulated from outside (of the cursor/loop).</p>
      </div>
    </div>
    <div id='footer'>
      <p>
        <span id='footer-left'>
          this website was created with
          <a href='http://nanoc.stoneship.org'>nanoc</a>
          and
          <a href='http://alexgorbatchev.com/SyntaxHighlighter/'>syntax highlighter</a>
        </span>
        <span id='footer-right'>
          &copy; 2005-2010 the ruote team
        </span>
      </p>
    </div>
    <script type='text/javascript'>
      //<![CDATA[
        SyntaxHighlighter.all();
      //]]>
    </script>
    <script src='http://www.google-analytics.com/ga.js' type='text/javascript'></script>
    <script type='text/javascript'>
      //<![CDATA[
        if (location.hostname != 'localhost' && location.hostname != '127.0.0.1') {
          var pageTracker=_gat._getTracker('UA-138748-2');
          pageTracker._initData();
          pageTracker._trackPageview();
        }
      //]]>
    </script>
  </body>
</html>
