<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />
    <title>ruote - dollar notation</title>
    <script src='/js/shCore.js'></script>
    <script src='/js/shBrushRuby.js'></script>
    <script src='/js/shBrushJScript.js'></script>
    <script src='/js/shBrushXml.js'></script>
    <link href='/css/reset.css' rel='stylesheet' type='text/css' />
    <link href='/css/shCore.css' rel='stylesheet' type='text/css' />
    <link href='/css/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <link href='/css/ruote.css' rel='stylesheet' type='text/css' />
  </head><body>
    <div id='container'>
      <div id='header'>
        <div id='header-top'>
          <div id='header-left'>
            <a href='/'>
              <img align='left' src='/images/ruote.png' />
              <span id='ruote' onclick="location.href = '/'; return true;">
                ruote 2.1
              </span>
            </a>
          </div>
          <div id='header-right'>
          </div>
        </div>
        <div id='header-bottom'>
          <div id='header-subtitle'>
            open source ruby workflow engine
          </div>
          <div id='header-menu'>
            <a href='documentation.html' title='documentation'>doc</a>
            <a href='source.html' title='source code'>source</a>
            <a href='download.html' title='download'>download</a>
            <a href='lists.html' title='mailing lists and irc'>lists</a>
            <a href='http://jmettraux.wordpress.com' title='blog'>blog</a>
            <a href='map.html' title='map'>map</a>
            <a class='nihongo' href='ja.html' title='日本語'>日本語</a>
          </div>
        </div>
      </div>
      <div id='content'>
        <h2>dollar notation</h2>
        <p>Most of the examples features plainly named participant like :</p>
        <pre class="brush: ruby">
          sequence do
            participant 'alfred'
            participant 'bob'
          end
        </pre>
        <p>But the real world is more dynamic :</p>
        <pre class="brush: ruby">
          sequence do
            participant '${f:patient}'
            participant '${f:doctor}'
          end
        </pre>
        <p>In that mini process definition, the workitem is routed from the patient to the doctor. The actual participant name is held in the workitem field &#8220;patient&#8221; and then in the field named &#8220;doctor&#8221;. Since it&#8217;s a sequence, the value in the field doctor could have been set by the patient.</p>
        <p>The prefix &#8216;f&#8217; comes for &#8216;field&#8217;, as in workitem field.</p>
        <h3>variables and workitem fields</h3>
        <p>Two types of data are available to process instances : process variables and workitem fields.</p>
        <p>The most visible type is workitem fields. Each workitem has a dictionary of fields as payload. Workitem and their fields are visible to the participants (ie outside of the workflow engine itself).</p>
        <p>Process variables are not communicated outside of the engine (except if the <a href="exp/set.html">set</a> expression is used to copy a variable to a field). Variables are mainly used for routing decisions inside the process instance.</p>
        <pre class="brush: ruby">
        Ruote.process_definition :name =&gt; 'loan_approval', :revision =&gt; '1' do
          cursor do
            participant 'planning team'
            concurrence do
              participant 'ceo' :if =&gt; '${f:total} &gt; 100000' do
              participant 'cfo'
            end
            rewind :unless =&gt; '${f:approved}'
            participant 'execution team'
          end
        end
        </pre>
        <p>In this first example process definition, there are two fields visible from the process definition : &#8216;total&#8217; and &#8216;approved&#8217;. The total has been determined by the planning team, while the &#8216;approved&#8217; field will be set by the cfo (and perhaps the ceo).</p>
        <p>Note that if the total is superior to 100&#8217;000, the ceo, concurrently with the cfo, will receive a workitem. Thus the workitem (and its fields) will get duplicated, one copy for each concurrence branch. Process variables never get &#8220;cloned&#8221; in this way.</p>
        <pre class="brush: ruby">
        Ruote.process_definition :name =&gt; 'loan_approval', :revision =&gt; '2' do
          cursor do
            participant 'planning team'
            concurrence do
              participant 'ceo' :if =&gt; '${v:supervised}' do
              participant 'cfo'
            end
            rewind :unless =&gt; '${f:approved}'
            participant 'execution team'
          end
        end
        </pre>
        <p>In that example, if the process variable &#8220;supervised&#8221; is set to true, the ceo will have his say in the iterations. The information about whether or not the process instance is supervised is not passed to participants (well obviously the ceo will know).</p>
        <h3 id="default">by default ${key} points to the field &#8216;key&#8217;</h3>
        <p>For ruote 2.1, this two process definitions are equivalent :</p>
        <pre class="brush: ruby">
          sequence do
            participant '${f:patient}'
            participant '${field:doctor}'
          end
        </pre>
        
        <pre class="brush: ruby">
          sequence do
            participant '${patient}'
            participant '${doctor}'
          end
        </pre>
        <h3 id="deep">deep lookup (composite keys)</h3>
        <p>Imagine you have this process definition :</p>
        <pre class="brush: ruby">
        Ruote.process_definition :name =&gt; 'contract preparation' do
          sequence do
        
            set "field:customer" =&gt; {
              'name' =&gt; 'Dexter Shipping', 'address' =&gt; [ 'Orchard Road', 'Singapore' ]}
                # setting some field f one way or the other
        
            # ...
            participant 'legal dept', :task =&gt; 'prepare contract for ${f:customer.name}'
            # ...
            participant 'asia supervisor', :if =&gt; '${f:customer.address.1} == Singapore'
            # ...
          end
        end
        </pre>
        <p>It&#8217;s OK to use dots and key names or integer indexes to look deep inside of a field or a variable (${v:partner.address.city}).</p>
        <h3 id="initial">initial fields and initial variables</h3>
        <p>Looking at the <a href="#deep">above example</a>, one thing should be clear : our customer information is hardcoded in the business process.</p>
        <p>Why not remove it ?</p>
        <pre class="brush: ruby">
        pdef = Ruote.process_definition :name =&gt; 'contract preparation' do
          sequence do
            participant 'legal dept', :task =&gt; 'prepare contract for ${f:customer.name}'
            # ...
            participant 'asia supervisor', :if =&gt; '${f:customer.address.1} == Singapore'
            # ...
          end
        end
        </pre>
        <p>and pass the information in due time, i.e. at launch time ?</p>
        <pre class="brush: ruby">
        ruote_engine.launch(
          pdef,
          { 'customer' =&gt; { 'name' =&gt; 'Dexter Shipping', 'address' =&gt; [ 'Orchard Road', 'Singapore' ] } })
        </pre>
        <p>The signature for the launch method looks like</p>
        <pre class="brush: ruby">
        def launch (process_definition, fields={}, variables={})
        </pre>
        <p>Fields are the initial fields (payload) of the workitem and variables are the initial variables at the root of the process instance getting launched.</p>
        <h3 id="wfid">${fei}, ${wfid}, ${sub_wfid} and ${expid}</h3>
        <p>This tiny program :</p>
        <pre class="brush: ruby">
        require 'rubygems'
        require 'ruote'
        
        engine = Ruote::Engine.new(Ruote::Worker.new(Ruote::HashStorage.new()))
        
        engine.register_participant :wrongdoer do |workitem|
          raise "I did something wrong"
        end
        
        pdef = Ruote.process_definition do
          sequence do
            echo 'fei       : ${fei}'
            echo 'wfid      : ${wfid}'
            echo 'expid     : ${expid}'
            echo 'sub_wfid  : ${sub_wfid}'
          end
        end
        
        wfid = engine.launch(pdef)
        
        engine.wait_for(wfid)
        </pre>
        <p>will emit to the standard output something like :</p>
        <pre>
        fei       : 0_0_0!!20100407-bipopopizu
        wfid      : 20100407-bipopopizu
        expid     : 0_0_2
        sub_wfid  :
        </pre>
        <p>These are not the content of the fields &#8216;fei&#8217;, &#8216;wfid&#8217;, &#8216;expid&#8217;, &#8216;sub_wfid&#8217;. It&#8217;s the flow expression id, the workflow instance id, the expression id and the sub workflow instance id.</p>
        <p>The &#8216;fei&#8217; is a compound of the three others.</p>
        <p>The &#8216;sub_wfid&#8217; is empty since our test process is very simple and the echo is not part of a sub-workflow.</p>
        <p>This technique can be used in various ways. Here is an example :</p>
        <pre class="brush: ruby">
        Ruote.process_definition :name =&gt; 'new batch' do
          sequence do
            set 'batch_id' =&gt; 'batch--${wfid}'
            clerks :task =&gt; 'input new batch'
            testers :task =&gt; 'schedule tests for new batch'
          end
        end
        </pre>
        <p>The field &#8216;batch_id&#8217; is set to something like &#8216;batch&#8212;20100407-barakuraba&#8217;.</p>
        <h3 id="ruby_eval_allowed">&#8216;ruby_eval_allowed&#8217;</h3>
        <p>When the engine is <a href="configuration.html#engine">configured</a> with &#8216;ruby_eval_allowed&#8217; =&gt; true, which boils down to</p>
        <pre class="brush: ruby">
        engine = Ruote::Engine.new(
          Ruote::Worker.new(
            Ruote::HashStorage.new('ruby_eval_allowed' =&gt; true)))
        </pre>
        <p>a special (and dangerous) &#8216;r&#8217; or &#8216;ruby&#8217; prefix gets unlocked.</p>
        <pre class="brush: ruby">
        Ruote.process_definition :name =&gt; 'new batch' do
          sequence do
            set 'batch_id' =&gt; '${r:Operations.generate_batch_id}'
            clerks :task =&gt; 'input new batch'
            testers :task =&gt; 'schedule tests for new batch'
            clerks :task =&gt; 'schedule transport', :if =&gt; '${r:Operations.no_transport_available?}'
          end
        end
        </pre>
        <p>This process definition calls to methods from the Operations module, one to generate a batch id and the second to check if transports are available.</p>
        <p>Ruote tries is best to prevent dangerous operations from happening whithin the ${r:xxx} envelope, but beware ! Especially if your process definitions are loaded from untrusted sources.</p>
      </div>
      <div id='footer'>
        <div id='footer-left'>
          this website was created with
          <a href='http://nanoc.stoneship.org'>nanoc</a>
          and
          <a href='http://alexgorbatchev.com/SyntaxHighlighter/'>syntax highlighter</a>
        </div>
        <div id='footer-right'>
          &copy; 2005-2010 the ruote team
        </div>
      </div>
    </div>
    <script type='text/javascript'>
      //<![CDATA[
        SyntaxHighlighter.all();
      //]]>
    </script>
    <script src='http://www.google-analytics.com/ga.js' type='text/javascript'></script>
    <script type='text/javascript'>
      //<![CDATA[
        if (location.hostname != 'localhost' && location.hostname != '127.0.0.1') {
          var pageTracker=_gat._getTracker('UA-138748-2');
          pageTracker._initData();
          pageTracker._trackPageview();
        }
      //]]>
    </script>
  </body>
</html>
