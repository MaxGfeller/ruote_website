---
title: process administration
filter:
  - erb
  - textile
---

h2. [business] process administration

The model of a business process usually focuses on a "happy path", everything happening according to the plan.

A few alternative paths may be added explicitely. Provisions for errors and timeouts may explicitely be added, thanks to ":on_error":common_attributes.html#on_error and ":on_timeout":common_attributes.html#on_timeout.

Sometimes, this is not enough. Processes may fall into errors, may stall (a participant reply got lost and there is no timeout) or they may simply become obsolete due to changes in their context.

Deciding whether an exception (error, timeout, ...) is dealt explicitely in the process definition often requires experience.

This page is about manipulating process instances.

Here is the span of possible actions :

* "querying":#query the engine about running process instances. Not an action, rather an observation

* "cancelling":#cancelling processes or segments of processes
* "cancelling process instances":#cancelling_process
* "cancelling expressions":#cancelling_expression
* "on_cancel":#on_cancel
* "killing vs cancelling":#killing

* "re_applying":#re_applying segments of process instances
* "re_applying a stalled expression":#re_applying_stalled
* "re_applying a tree":#re_applying_tree
* "re_applying and changing the [workitem] fields":#re_applying_fields

* "errors":#errors
* "replaying at errors":#errors_replay
* "cancelling at errors":#errors_cancel
* "on_error":#on_error

***

h3(#query). querying the engine about running process instances

To list all the processes currently running in the engine ("rdoc":http://ruote.rubyforge.org/rdoc/Ruote/Engine.html#processes-instance_method) :

<% coderay(:lang => 'ruby', :line_numbers => 'inline') do -%>
  statuses = engine.processes
<% end %>

To query about a process, known by its "wfid" (workflow instance id) ("rdoc":http://ruote.rubyforge.org/rdoc/Ruote/Engine.html#process-instance_method) :

<% coderay(:lang => 'ruby', :line_numbers => 'inline') do -%>
  status = engine.process(wfid)
<% end %>

Those two methods return "ProcessStatus":http://ruote.rubyforge.org/rdoc/Ruote/ProcessStatus.html instances.

***

h3(#cancelling). cancelling

Cancelling is about terminating the execution of a process instance or of a branch of it.

Cancelling cannot occur in one operation. The engine traverses the tree of execution and cancels alive expressions one by one. Active participants receive a cancel message indicating which the id of the workitem to cancel.

h4(#cancelling_process). cancelling : process instances

<% coderay(:lang => 'ruby', :line_numbers => 'inline') do -%>
  engine.cancel_process(wfid)
<% end %>

Warning : as explained cancelling a process or a branch of a process isn't instantaneous.

h4(#cancelling_expression). cancelling : expressions

Perhaps, the most common use case for "cancelling an expression" is cancelling a participant expression.

Let's say you have this process :

<div style="width: 100%; position: relative;">
<% coderay(:lang => 'ruby', :line_numbers => 'inline') do -%>
  Ruote.process_definition do
    sequence do
      logistics
      delivery
      accounting
    end
  end
<% end %>
  <div style="position: absolute; top: -20px; right: 75px;">
    <img src="/images/cancelling_expression.png" width="100%"/>
  </div>
</div>

For some reason, this process was triggered for an online product, which was downloaded successfully. The delivery is not necessary, but the delivery participant has already received the workitem for this process instance.

Cancelling the delivery participant expression would let the flow continue to "accounting". Programmatically that would look like :

<% coderay(:lang => 'ruby', :line_numbers => 'inline') do -%>
  status = engine.process(wfid)

  exp = status.expressions.first

  engine.cancel_expression(exp.fei)
<% end %>

Warning : as explained cancelling a process or a branch of a process isn't instantaneous.


h4(#on_cancel). on_cancel

Most of the time, the process definition attempts to model the "happy path", the process as it occurs 95% of the time. One may want to go a step further and incclude provisions for errors (see "on_error":#on_error) and for cancellations.

<% coderay(:lang => 'ruby', :line_numbers => 'inline') do -%>
  Ruote.process_definition do
    sequence :on_cancel => 'admin' do
      logistics
      delivery
      accounting
    end
  end
<% end %>

In this process definition, if the process or the sequence gets cancelled, the 'admin' subprocess (or the participant 'admin') will be applied (or simply receive a workitem).

More info about "on_cancel":common_attributes.html#on_cancel.


h4(#killing). killing vs cancelling

Processes (and expressions) can be cancelled or they can be killed. Killing looks much like cancelling, except that any "on_cancel":common_attributes.html#on_cancel will be ignored.

***

h3(#re_applying). re_applying

The "Engine#re_apply(fei, options)":http://ruote.rubyforge.org/rdoc/Ruote/Engine.html#method-i-re_apply method cancels and expression and re_applies. It has a few options for dealing with some process repair tasks.

Most of the technique described here are tested in ruote's "ft_14_re_apply.rb":http://github.com/jmettraux/ruote/blob/ruote2.1/test/functional/ft_14_re_apply.rb


h4(#re_applying_stalled). re_applying a stalled [participant] expression

Sometimes participants don't reply and the participant expression that emitted the workitem to them is stuck waiting. Or simply the engine could have been down when the participant answer came and the answer got lost.

With a 're_apply', it's possible to re-apply the delivery and hopefully restart the interaction (though that could ultimately depend on the participant implementation).

<% coderay(:lang => 'ruby', :line_numbers => 'inline') do -%>
  pdef = Ruote.process_definition do
    sequence do
      alpha
      bravo
    end
  end

  wfid = engine.launch(pdef)

  # ... process stalls at participant alpha ...

  stalled_fexp = engine.process(wfid).expressions.last
    #
    # expressions in process status (as returned by Engine#process) are
    # ordered with the root as the first and the leaves in the last positions

  engine.re_apply(stalled_fexp.fei)
    #
    # will cancel the expression at 'alpha' and re_apply it, triggering
    # a new dispatch to the participant alpha points to.
<% end %>


h4(#re_applying_tree). re_applying a process branch that went wrong

If a process branch went wrong, it's sometimes necessary to redo it.

Some process developers like to include those "something went wrong" paths as extension to the happy path and they use the "cursor":exp/cursor.html expression with some 'rewind' magic. But sometimes it's really necessary to rewind/redo manually.

<% coderay(:lang => 'ruby', :line_numbers => 'inline') do -%>
require 'rubygems'
require 'yajl'
require 'ruote'

engine = Ruote::Engine.new(Ruote::Worker.new(Ruote::HashStorage.new))

pdef = Ruote.define do
  sequence do
    alpha
    bravo
    zebulon
  end
end

class ThisParticipant
  include Ruote::LocalParticipant
  def consume (workitem)
    puts "* #{workitem.participant_name}"
    reply_to_engine(workitem)
  end
end
class ThatParticipant
  include Ruote::LocalParticipant
  def consume (workitem)
    puts ". #{workitem.participant_name}"
    # no reply to engine
  end
  def cancel (fei, flavour)
    # ok, let pass
  end
  def do_not_thread; true; end
end

engine.register_participant 'alpha', ThisParticipant
engine.register_participant 'bravo', ThisParticipant
engine.register_participant 'charlie', ThisParticipant
engine.register_participant 'zebulon', ThatParticipant

#engine.context.logger.noisy = true

wfid = engine.launch(pdef)

engine.wait_for(:zebulon)

# ... process reached 'zebulon', but there something wrong
#     we need to redo that sequence differently ...

ps = engine.process(wfid)

sequence = ps.expressions.find { |fexp| fexp.fei.expid == '0_0' }
  # first child '0' after the root '0' => '0_0'

puts "re_applying..."

engine.re_apply(sequence.fei, :tree => Ruote.to_tree do
  sequence do
    charlie
    bravo
    alpha
  end
end)

engine.wait_for(wfid)
<% end %>
(gist at "http://gist.github.com/485559":http://gist.github.com/485559)

This self-containing example will output :

<pre>
* alpha
* bravo
. zebulon
re_applying...
* charlie
* bravo
* alpha
</pre>

The key here is the :tree option passed to re_apply, it gives that has to be applied instead of the target expression.


h4(#re_applying_fields). re_applying and changing the [workitem] fields

When re_applying, the workitem used for the re_apply is the one used to originally apply.

The re_apply method accepts the :fields and :merge_in_fields options. :fields completely changes the workitem payload used for the re_apply, while the :merge_in_fields, allows to add new fields to the workitem payload.

A few examples :

<% coderay(:lang => 'ruby', :line_numbers => 'inline') do -%>
engine.re_apply(fei, :fields => { 'customer' => 'Alfred' })

engine.re_apply(fei, :merge_in_fields => { 'customer' => 'Alfred' })

engine.re_apply(
  fei,
  :fields => { 'customer' => 'Alfred', 'items' => [ 124, 356, 798 ] },
  :tree => Ruote.to_tree { sequence { print_invoice; package; ship } })
<% end %>

***

h3(#errors). process errors

TODO

(For now, have a look at "this thread":http://groups.google.com/group/openwferu-users/browse_thread/thread/fbe9785b26d9aa40 or "that one":http://groups.google.com/group/openwferu-users/browse_thread/thread/c788f462b2e2e2e)

h4(#errors_replay). errors : replaying

TODO

h4(#errors_cancel). errors : cancelling

TODO

h4(#on_error). on_error

TODO

